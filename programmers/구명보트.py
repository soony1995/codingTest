def solution(people, limit) :
    answer = 0
    people.sort()

    a = 0
    b = len(people) - 1
    while a < b :
        if people[b] + people[a] <= limit :
            a += 1
            answer += 1
        b -= 1
    return len(people) - answer

print(solution([70, 50, 80, 50],	100))

# ********** 노트 ************
# 두 포인터가 교차하는 순간 종료 
# 왼쪽 ->          <- 오른쪽 

# for문 2개를 이용하면 
# -> 
# -> -> -> -> 
# -> -> 
# -> -> -> -> 

# 투 포인터를 이용하면 while이용 
# ->       <-
# ->     <-<-
# ->   <-<-<-
#처음 과 끝을 비교하면서 움직일 수 있다.

# *********** 문제 풀이 하면서 한 생각들 ************
# 한곳에 차례로 넣어놓고 마지막에 넣은 값이 limit를 넘으면 넣은 행위를 취소
# 하고 그 스택을 비운다.
# 현재 쌓인 값 + 다음 값 > limit 이면 
# 현재 쌓인 값을 비우고 cnt +1 
# 다음 값을 append 

#한 보트에 2명 무게 제한있음.
#인접한 두 인덱스 값을 비교하는 문제 -> stack으로 푸는게 나아보임.
# 정렬 후, 앞에서 부터 한명씩 뽑아서 무게 제한에 걸리는 확인하면됨.
#구명 보트는 최대한 적게, -> 필요한 구명보트의 개수 리턴 

# **************** 풀지 못한 이유 ******************
#문제를 못푼 이유: 접근법이 잘못 되었음.
#맨앞과 맨뒤 사람을 매칭해서 확인을 해야함. 
#해당 되는 사람들을 pop 할 생각을 헀음. -> 이렇게 할 경우 시간 복잡도가 늘어남.
#전체에서 - 해당되는 사람 = 답  
